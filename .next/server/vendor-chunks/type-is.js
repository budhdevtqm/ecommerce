"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/type-is";
exports.ids = ["vendor-chunks/type-is"];
exports.modules = {

/***/ "(rsc)/./node_modules/type-is/index.js":
/*!***************************************!*\
  !*** ./node_modules/type-is/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */ \n/**\n * Module dependencies.\n * @private\n */ var typer = __webpack_require__(/*! media-typer */ \"(rsc)/./node_modules/media-typer/index.js\");\nvar mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\n/**\n * Module exports.\n * @public\n */ module.exports = typeofrequest;\nmodule.exports.is = typeis;\nmodule.exports.hasBody = hasbody;\nmodule.exports.normalize = normalize;\nmodule.exports.match = mimeMatch;\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */ function typeis(value, types_) {\n    var i;\n    var types = types_;\n    // remove parameters and normalize\n    var val = tryNormalizeType(value);\n    // no type or invalid\n    if (!val) {\n        return false;\n    }\n    // support flattened arguments\n    if (types && !Array.isArray(types)) {\n        types = new Array(arguments.length - 1);\n        for(i = 0; i < types.length; i++){\n            types[i] = arguments[i + 1];\n        }\n    }\n    // no types, return the content type\n    if (!types || !types.length) {\n        return val;\n    }\n    var type;\n    for(i = 0; i < types.length; i++){\n        if (mimeMatch(normalize(type = types[i]), val)) {\n            return type[0] === \"+\" || type.indexOf(\"*\") !== -1 ? val : type;\n        }\n    }\n    // no matches\n    return false;\n}\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */ function hasbody(req) {\n    return req.headers[\"transfer-encoding\"] !== undefined || !isNaN(req.headers[\"content-length\"]);\n}\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */ function typeofrequest(req, types_) {\n    var types = types_;\n    // no body\n    if (!hasbody(req)) {\n        return null;\n    }\n    // support flattened arguments\n    if (arguments.length > 2) {\n        types = new Array(arguments.length - 1);\n        for(var i = 0; i < types.length; i++){\n            types[i] = arguments[i + 1];\n        }\n    }\n    // request content type\n    var value = req.headers[\"content-type\"];\n    return typeis(value, types);\n}\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */ function normalize(type) {\n    if (typeof type !== \"string\") {\n        // invalid type\n        return false;\n    }\n    switch(type){\n        case \"urlencoded\":\n            return \"application/x-www-form-urlencoded\";\n        case \"multipart\":\n            return \"multipart/*\";\n    }\n    if (type[0] === \"+\") {\n        // \"+json\" -> \"*/*+json\" expando\n        return \"*/*\" + type;\n    }\n    return type.indexOf(\"/\") === -1 ? mime.lookup(type) : type;\n}\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */ function mimeMatch(expected, actual) {\n    // invalid type\n    if (expected === false) {\n        return false;\n    }\n    // split types\n    var actualParts = actual.split(\"/\");\n    var expectedParts = expected.split(\"/\");\n    // invalid format\n    if (actualParts.length !== 2 || expectedParts.length !== 2) {\n        return false;\n    }\n    // validate type\n    if (expectedParts[0] !== \"*\" && expectedParts[0] !== actualParts[0]) {\n        return false;\n    }\n    // validate suffix wildcard\n    if (expectedParts[1].substr(0, 2) === \"*+\") {\n        return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);\n    }\n    // validate subtype\n    if (expectedParts[1] !== \"*\" && expectedParts[1] !== actualParts[1]) {\n        return false;\n    }\n    return true;\n}\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */ function normalizeType(value) {\n    // parse the type\n    var type = typer.parse(value);\n    // remove the parameters\n    type.parameters = undefined;\n    // reformat it\n    return typer.format(type);\n}\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */ function tryNormalizeType(value) {\n    if (!value) {\n        return null;\n    }\n    try {\n        return normalizeType(value);\n    } catch (err) {\n        return null;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZS1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQyxHQUVEO0FBRUE7OztDQUdDLEdBRUQsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFFbkI7OztDQUdDLEdBRURFLE9BQU9DLE9BQU8sR0FBR0M7QUFDakJGLGlCQUFpQixHQUFHSTtBQUNwQkosc0JBQXNCLEdBQUdNO0FBQ3pCTix3QkFBd0IsR0FBR087QUFDM0JQLG9CQUFvQixHQUFHUztBQUV2Qjs7Ozs7Ozs7Ozs7O0NBWUMsR0FFRCxTQUFTTCxPQUFRTSxLQUFLLEVBQUVDLE1BQU07SUFDNUIsSUFBSUM7SUFDSixJQUFJQyxRQUFRRjtJQUVaLGtDQUFrQztJQUNsQyxJQUFJRyxNQUFNQyxpQkFBaUJMO0lBRTNCLHFCQUFxQjtJQUNyQixJQUFJLENBQUNJLEtBQUs7UUFDUixPQUFPO0lBQ1Q7SUFFQSw4QkFBOEI7SUFDOUIsSUFBSUQsU0FBUyxDQUFDRyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7UUFDbENBLFFBQVEsSUFBSUcsTUFBTUUsVUFBVUMsTUFBTSxHQUFHO1FBQ3JDLElBQUtQLElBQUksR0FBR0EsSUFBSUMsTUFBTU0sTUFBTSxFQUFFUCxJQUFLO1lBQ2pDQyxLQUFLLENBQUNELEVBQUUsR0FBR00sU0FBUyxDQUFDTixJQUFJLEVBQUU7UUFDN0I7SUFDRjtJQUVBLG9DQUFvQztJQUNwQyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0EsTUFBTU0sTUFBTSxFQUFFO1FBQzNCLE9BQU9MO0lBQ1Q7SUFFQSxJQUFJTTtJQUNKLElBQUtSLElBQUksR0FBR0EsSUFBSUMsTUFBTU0sTUFBTSxFQUFFUCxJQUFLO1FBQ2pDLElBQUlILFVBQVVGLFVBQVVhLE9BQU9QLEtBQUssQ0FBQ0QsRUFBRSxHQUFHRSxNQUFNO1lBQzlDLE9BQU9NLElBQUksQ0FBQyxFQUFFLEtBQUssT0FBT0EsS0FBS0MsT0FBTyxD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QWM7SUFDZCxPQUFPM0IsTUFBTXVDLE1BQU0sQ0FBQ2hCO0FBQ3RCO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU0wsaUJBQWtCTCxLQUFLO0lBQzlCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixPQUFPdUIsY0FBY3ZCO0lBQ3ZCLEVBQUUsT0FBTzJCLEtBQUs7UUFDWixPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2UtY29tLy4vbm9kZV9tb2R1bGVzL3R5cGUtaXMvaW5kZXguanM/NTc0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHR5cGUtaXNcbiAqIENvcHlyaWdodChjKSAyMDE0IEpvbmF0aGFuIE9uZ1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHR5cGVyID0gcmVxdWlyZSgnbWVkaWEtdHlwZXInKVxudmFyIG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJylcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZnJlcXVlc3Rcbm1vZHVsZS5leHBvcnRzLmlzID0gdHlwZWlzXG5tb2R1bGUuZXhwb3J0cy5oYXNCb2R5ID0gaGFzYm9keVxubW9kdWxlLmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplXG5tb2R1bGUuZXhwb3J0cy5tYXRjaCA9IG1pbWVNYXRjaFxuXG4vKipcbiAqIENvbXBhcmUgYSBgdmFsdWVgIGNvbnRlbnQtdHlwZSB3aXRoIGB0eXBlc2AuXG4gKiBFYWNoIGB0eXBlYCBjYW4gYmUgYW4gZXh0ZW5zaW9uIGxpa2UgYGh0bWxgLFxuICogYSBzcGVjaWFsIHNob3J0Y3V0IGxpa2UgYG11bHRpcGFydGAgb3IgYHVybGVuY29kZWRgLFxuICogb3IgYSBtaW1lIHR5cGUuXG4gKlxuICogSWYgbm8gdHlwZXMgbWF0Y2gsIGBmYWxzZWAgaXMgcmV0dXJuZWQuXG4gKiBPdGhlcndpc2UsIHRoZSBmaXJzdCBgdHlwZWAgdGhhdCBtYXRjaGVzIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB0eXBlaXMgKHZhbHVlLCB0eXBlc18pIHtcbiAgdmFyIGlcbiAgdmFyIHR5cGVzID0gdHlwZXNfXG5cbiAgLy8gcmVtb3ZlIHBhcmFtZXRlcnMgYW5kIG5vcm1hbGl6ZVxuICB2YXIgdmFsID0gdHJ5Tm9ybWFsaXplVHlwZSh2YWx1ZSlcblxuICAvLyBubyB0eXBlIG9yIGludmFsaWRcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIHN1cHBvcnQgZmxhdHRlbmVkIGFyZ3VtZW50c1xuICBpZiAodHlwZXMgJiYgIUFycmF5LmlzQXJyYXkodHlwZXMpKSB7XG4gICAgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgZm9yIChpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0eXBlc1tpXSA9IGFyZ3VtZW50c1tpICsgMV1cbiAgICB9XG4gIH1cblxuICAvLyBubyB0eXBlcywgcmV0dXJuIHRoZSBjb250ZW50IHR5cGVcbiAgaWYgKCF0eXBlcyB8fCAhdHlwZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgdmFyIHR5cGVcbiAgZm9yIChpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pbWVNYXRjaChub3JtYWxpemUodHlwZSA9IHR5cGVzW2ldKSwgdmFsKSkge1xuICAgICAgcmV0dXJuIHR5cGVbMF0gPT09ICcrJyB8fCB0eXBlLmluZGV4T2YoJyonKSAhPT0gLTFcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB0eXBlXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gbWF0Y2hlc1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHJlcXVlc3QgaGFzIGEgcmVxdWVzdCBib2R5LlxuICogQSByZXF1ZXN0IHdpdGggYSBib2R5IF9fbXVzdF9fIGVpdGhlciBoYXZlIGB0cmFuc2Zlci1lbmNvZGluZ2BcbiAqIG9yIGBjb250ZW50LWxlbmd0aGAgaGVhZGVycyBzZXQuXG4gKiBodHRwOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzQuaHRtbCNzZWM0LjNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNib2R5IChyZXEpIHtcbiAgcmV0dXJuIHJlcS5oZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddICE9PSB1bmRlZmluZWQgfHxcbiAgICAhaXNOYU4ocmVxLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGluY29taW5nIHJlcXVlc3QgY29udGFpbnMgdGhlIFwiQ29udGVudC1UeXBlXCJcbiAqIGhlYWRlciBmaWVsZCwgYW5kIGl0IGNvbnRhaW5zIGFueSBvZiB0aGUgZ2l2ZSBtaW1lIGB0eXBlYHMuXG4gKiBJZiB0aGVyZSBpcyBubyByZXF1ZXN0IGJvZHksIGBudWxsYCBpcyByZXR1cm5lZC5cbiAqIElmIHRoZXJlIGlzIG5vIGNvbnRlbnQgdHlwZSwgYGZhbHNlYCBpcyByZXR1cm5lZC5cbiAqIE90aGVyd2lzZSwgaXQgcmV0dXJucyB0aGUgZmlyc3QgYHR5cGVgIHRoYXQgbWF0Y2hlcy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgLy8gV2l0aCBDb250ZW50LVR5cGU6IHRleHQvaHRtbDsgY2hhcnNldD11dGYtOFxuICogICAgIHRoaXMuaXMoJ2h0bWwnKTsgLy8gPT4gJ2h0bWwnXG4gKiAgICAgdGhpcy5pcygndGV4dC9odG1sJyk7IC8vID0+ICd0ZXh0L2h0bWwnXG4gKiAgICAgdGhpcy5pcygndGV4dC8qJywgJ2FwcGxpY2F0aW9uL2pzb24nKTsgLy8gPT4gJ3RleHQvaHRtbCdcbiAqXG4gKiAgICAgLy8gV2hlbiBDb250ZW50LVR5cGUgaXMgYXBwbGljYXRpb24vanNvblxuICogICAgIHRoaXMuaXMoJ2pzb24nLCAndXJsZW5jb2RlZCcpOyAvLyA9PiAnanNvbidcbiAqICAgICB0aGlzLmlzKCdhcHBsaWNhdGlvbi9qc29uJyk7IC8vID0+ICdhcHBsaWNhdGlvbi9qc29uJ1xuICogICAgIHRoaXMuaXMoJ2h0bWwnLCAnYXBwbGljYXRpb24vKicpOyAvLyA9PiAnYXBwbGljYXRpb24vanNvbidcbiAqXG4gKiAgICAgdGhpcy5pcygnaHRtbCcpOyAvLyA9PiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlcy4uLlxuICogQHJldHVybiB7U3RyaW5nfGZhbHNlfG51bGx9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdHlwZW9mcmVxdWVzdCAocmVxLCB0eXBlc18pIHtcbiAgdmFyIHR5cGVzID0gdHlwZXNfXG5cbiAgLy8gbm8gYm9keVxuICBpZiAoIWhhc2JvZHkocmVxKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgdHlwZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdHlwZXNbaV0gPSBhcmd1bWVudHNbaSArIDFdXG4gICAgfVxuICB9XG5cbiAgLy8gcmVxdWVzdCBjb250ZW50IHR5cGVcbiAgdmFyIHZhbHVlID0gcmVxLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG5cbiAgcmV0dXJuIHR5cGVpcyh2YWx1ZSwgdHlwZXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgbWltZSB0eXBlLlxuICogSWYgaXQncyBhIHNob3J0aGFuZCwgZXhwYW5kIGl0IHRvIGEgdmFsaWQgbWltZSB0eXBlLlxuICpcbiAqIEluIGdlbmVyYWwsIHlvdSBwcm9iYWJseSB3YW50OlxuICpcbiAqICAgdmFyIHR5cGUgPSBpcyhyZXEsIFsndXJsZW5jb2RlZCcsICdqc29uJywgJ211bHRpcGFydCddKTtcbiAqXG4gKiBUaGVuIHVzZSB0aGUgYXBwcm9wcmlhdGUgYm9keSBwYXJzZXJzLlxuICogVGhlc2UgdGhyZWUgYXJlIHRoZSBtb3N0IGNvbW1vbiByZXF1ZXN0IGJvZHkgdHlwZXNcbiAqIGFuZCBhcmUgdGh1cyBlbnN1cmVkIHRvIHdvcmsuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplICh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBpbnZhbGlkIHR5cGVcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3VybGVuY29kZWQnOlxuICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgY2FzZSAnbXVsdGlwYXJ0JzpcbiAgICAgIHJldHVybiAnbXVsdGlwYXJ0LyonXG4gIH1cblxuICBpZiAodHlwZVswXSA9PT0gJysnKSB7XG4gICAgLy8gXCIranNvblwiIC0+IFwiKi8qK2pzb25cIiBleHBhbmRvXG4gICAgcmV0dXJuICcqLyonICsgdHlwZVxuICB9XG5cbiAgcmV0dXJuIHR5cGUuaW5kZXhPZignLycpID09PSAtMVxuICAgID8gbWltZS5sb29rdXAodHlwZSlcbiAgICA6IHR5cGVcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgZXhwZWN0ZWRgIG1pbWUgdHlwZVxuICogbWF0Y2hlcyBgYWN0dWFsYCBtaW1lIHR5cGUgd2l0aFxuICogd2lsZGNhcmQgYW5kICtzdWZmaXggc3VwcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwZWN0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3R1YWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1pbWVNYXRjaCAoZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAvLyBpbnZhbGlkIHR5cGVcbiAgaWYgKGV4cGVjdGVkID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gc3BsaXQgdHlwZXNcbiAgdmFyIGFjdHVhbFBhcnRzID0gYWN0dWFsLnNwbGl0KCcvJylcbiAgdmFyIGV4cGVjdGVkUGFydHMgPSBleHBlY3RlZC5zcGxpdCgnLycpXG5cbiAgLy8gaW52YWxpZCBmb3JtYXRcbiAgaWYgKGFjdHVhbFBhcnRzLmxlbmd0aCAhPT0gMiB8fCBleHBlY3RlZFBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgdHlwZVxuICBpZiAoZXhwZWN0ZWRQYXJ0c1swXSAhPT0gJyonICYmIGV4cGVjdGVkUGFydHNbMF0gIT09IGFjdHVhbFBhcnRzWzBdKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyB2YWxpZGF0ZSBzdWZmaXggd2lsZGNhcmRcbiAgaWYgKGV4cGVjdGVkUGFydHNbMV0uc3Vic3RyKDAsIDIpID09PSAnKisnKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkUGFydHNbMV0ubGVuZ3RoIDw9IGFjdHVhbFBhcnRzWzFdLmxlbmd0aCArIDEgJiZcbiAgICAgIGV4cGVjdGVkUGFydHNbMV0uc3Vic3RyKDEpID09PSBhY3R1YWxQYXJ0c1sxXS5zdWJzdHIoMSAtIGV4cGVjdGVkUGFydHNbMV0ubGVuZ3RoKVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgc3VidHlwZVxuICBpZiAoZXhwZWN0ZWRQYXJ0c1sxXSAhPT0gJyonICYmIGV4cGVjdGVkUGFydHNbMV0gIT09IGFjdHVhbFBhcnRzWzFdKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHR5cGUgYW5kIHJlbW92ZSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVUeXBlICh2YWx1ZSkge1xuICAvLyBwYXJzZSB0aGUgdHlwZVxuICB2YXIgdHlwZSA9IHR5cGVyLnBhcnNlKHZhbHVlKVxuXG4gIC8vIHJlbW92ZSB0aGUgcGFyYW1ldGVyc1xuICB0eXBlLnBhcmFtZXRlcnMgPSB1bmRlZmluZWRcblxuICAvLyByZWZvcm1hdCBpdFxuICByZXR1cm4gdHlwZXIuZm9ybWF0KHR5cGUpXG59XG5cbi8qKlxuICogVHJ5IHRvIG5vcm1hbGl6ZSBhIHR5cGUgYW5kIHJlbW92ZSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnlOb3JtYWxpemVUeXBlICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVR5cGUodmFsdWUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ0eXBlciIsInJlcXVpcmUiLCJtaW1lIiwibW9kdWxlIiwiZXhwb3J0cyIsInR5cGVvZnJlcXVlc3QiLCJpcyIsInR5cGVpcyIsImhhc0JvZHkiLCJoYXNib2R5Iiwibm9ybWFsaXplIiwibWF0Y2giLCJtaW1lTWF0Y2giLCJ2YWx1ZSIsInR5cGVzXyIsImkiLCJ0eXBlcyIsInZhbCIsInRyeU5vcm1hbGl6ZVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ0eXBlIiwiaW5kZXhPZiIsInJlcSIsImhlYWRlcnMiLCJ1bmRlZmluZWQiLCJpc05hTiIsImxvb2t1cCIsImV4cGVjdGVkIiwiYWN0dWFsIiwiYWN0dWFsUGFydHMiLCJzcGxpdCIsImV4cGVjdGVkUGFydHMiLCJzdWJzdHIiLCJub3JtYWxpemVUeXBlIiwicGFyc2UiLCJwYXJhbWV0ZXJzIiwiZm9ybWF0IiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/type-is/index.js\n");

/***/ })

};
;