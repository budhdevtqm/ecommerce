/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-typer";
exports.ids = ["vendor-chunks/media-typer"];
exports.modules = {

/***/ "(rsc)/./node_modules/media-typer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/media-typer/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * media-typer\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */ /**\n * RegExp to match *( \";\" parameter ) in RFC 2616 sec 3.7\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * SHT           = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n */ var paramRegExp = /; *([!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) *= *(\"(?:[ !\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u0020-\\u007e])*\"|[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) */g;\nvar textRegExp = /^[\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+$/;\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n */ var qescRegExp = /\\\\([\\u0000-\\u007f])/g;\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n */ var quoteRegExp = /([\\\\\"])/g;\n/**\n * RegExp to match type in RFC 6838\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */ var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;\nvar typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;\nvar typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;\n/**\n * Module exports.\n */ exports.format = format;\nexports.parse = parse;\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @api public\n */ function format(obj) {\n    if (!obj || typeof obj !== \"object\") {\n        throw new TypeError(\"argument obj is required\");\n    }\n    var parameters = obj.parameters;\n    var subtype = obj.subtype;\n    var suffix = obj.suffix;\n    var type = obj.type;\n    if (!type || !typeNameRegExp.test(type)) {\n        throw new TypeError(\"invalid type\");\n    }\n    if (!subtype || !subtypeNameRegExp.test(subtype)) {\n        throw new TypeError(\"invalid subtype\");\n    }\n    // format as type/subtype\n    var string = type + \"/\" + subtype;\n    // append +suffix\n    if (suffix) {\n        if (!typeNameRegExp.test(suffix)) {\n            throw new TypeError(\"invalid suffix\");\n        }\n        string += \"+\" + suffix;\n    }\n    // append parameters\n    if (parameters && typeof parameters === \"object\") {\n        var param;\n        var params = Object.keys(parameters).sort();\n        for(var i = 0; i < params.length; i++){\n            param = params[i];\n            if (!tokenRegExp.test(param)) {\n                throw new TypeError(\"invalid parameter name\");\n            }\n            string += \"; \" + param + \"=\" + qstring(parameters[param]);\n        }\n    }\n    return string;\n}\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @api public\n */ function parse(string) {\n    if (!string) {\n        throw new TypeError(\"argument string is required\");\n    }\n    // support req/res-like objects as argument\n    if (typeof string === \"object\") {\n        string = getcontenttype(string);\n    }\n    if (typeof string !== \"string\") {\n        throw new TypeError(\"argument string is required to be a string\");\n    }\n    var index = string.indexOf(\";\");\n    var type = index !== -1 ? string.substr(0, index) : string;\n    var key;\n    var match;\n    var obj = splitType(type);\n    var params = {};\n    var value;\n    paramRegExp.lastIndex = index;\n    while(match = paramRegExp.exec(string)){\n        if (match.index !== index) {\n            throw new TypeError(\"invalid parameter format\");\n        }\n        index += match[0].length;\n        key = match[1].toLowerCase();\n        value = match[2];\n        if (value[0] === '\"') {\n            // remove quotes and escapes\n            value = value.substr(1, value.length - 2).replace(qescRegExp, \"$1\");\n        }\n        params[key] = value;\n    }\n    if (index !== -1 && index !== string.length) {\n        throw new TypeError(\"invalid parameter format\");\n    }\n    obj.parameters = params;\n    return obj;\n}\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @api private\n */ function getcontenttype(obj) {\n    if (typeof obj.getHeader === \"function\") {\n        // res-like\n        return obj.getHeader(\"content-type\");\n    }\n    if (typeof obj.headers === \"object\") {\n        // req-like\n        return obj.headers && obj.headers[\"content-type\"];\n    }\n}\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @api private\n */ function qstring(val) {\n    var str = String(val);\n    // no need to quote tokens\n    if (tokenRegExp.test(str)) {\n        return str;\n    }\n    if (str.length > 0 && !textRegExp.test(str)) {\n        throw new TypeError(\"invalid parameter value\");\n    }\n    return '\"' + str.replace(quoteRegExp, \"\\\\$1\") + '\"';\n}\n/**\n * Simply \"type/subtype+siffx\" into parts.\n *\n * @param {string} string\n * @return {Object}\n * @api private\n */ function splitType(string) {\n    var match = typeRegExp.exec(string.toLowerCase());\n    if (!match) {\n        throw new TypeError(\"invalid media type\");\n    }\n    var type = match[1];\n    var subtype = match[2];\n    var suffix;\n    // suffix after last +\n    var index = subtype.lastIndexOf(\"+\");\n    if (index !== -1) {\n        suffix = subtype.substr(index + 1);\n        subtype = subtype.substr(0, index);\n    }\n    var obj = {\n        type: type,\n        subtype: subtype,\n        suffix: suffix\n    };\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVkaWEtdHlwZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBQ0QsSUFBSUEsY0FBYztBQUNsQixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGNBQWM7QUFFbEI7Ozs7O0NBS0MsR0FDRCxJQUFJQyxhQUFhO0FBRWpCOztDQUVDLEdBQ0QsSUFBSUMsY0FBYztBQUVsQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGFBQWE7QUFFakI7O0NBRUMsR0FFREMsY0FBYyxHQUFHQztBQUNqQkQsYUFBYSxHQUFHRTtBQUVoQjs7Ozs7O0NBTUMsR0FFRCxTQUFTRCxPQUFPRSxHQUFHO0lBQ2pCLElBQUksQ0FBQ0EsT0FBTyxPQUFPQSxRQUFRLFVBQVU7UUFDbkMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0lBRUEsSUFBSUMsYUFBYUYsSUFBSUUsVUFBVTtJQUMvQixJQUFJQyxVQUFVSCxJQUFJRyxPQUFPO0lBQ3pCLElBQUlDLFNBQVNKLElBQUlJLE1BQU07SUFDdkIsSUFBSUMsT0FBT0wsSUFBSUssSUFBSTtJQUVuQixJQUFJLENBQUNBLFFBQVEsQ0FBQ1YsZUFBZVcsSUFBSSxDQUFDRCxPQUFPO1FBQ3ZDLE1BQU0sSUFBSUosVUFBVTtJQUN0QjtJQUVBLElBQUksQ0FBQ0UsV0FBVyxDQUFDVCxrQkFBa0JZLElBQUksQ0FBQ0gsVUFBVTtRQUNoRCxNQUFNLElBQUlGLFVBQVU7SUFDdEI7SUFFQSx5QkFBeUI7SUFDekIsSUFBSU0sU0FBU0YsT0FBTyxNQUFNRjtJQUUxQixpQkFBaUI7SUFDakIsSUFBSUMsUUFBUTtRQUNWLElBQUksQ0FBQ1QsZUFBZVcsSUFBSSxDQUFDRixTQUFTO1lBQ2hDLE1BQU0sSUFBSUgsVUFBVTtRQUN0QjtRQUVBTSxVQUFVLE1BQU1IO0lBQ2xCO0lBRUEsb0JBQW9CO0lBQ3BCLElBQUlGLGNBQWMsT0FBT0EsZUFBZSxVQUFVO1FBQ2hELElBQUlNO1FBQ0osSUFBSUMsU0FBU0MsT0FBT0MsSUFBSSxDQUFDVCxZQUFZVSxJQUFJO1FBRXpDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixPQUFPSyxNQUFNLEVBQUVELElBQUs7WUFDdENMLFFBQVFDLE1BQU0sQ0FBQ0ksRUFBRTtZQUVqQixJQUFJLENBQUN0QixZQUFZZSxJQUFJLENBQUNFLFFBQVE7Z0JBQzVCLE1BQU0sSUFBSVAsVUFBVTtZQUN0QjtZQUVBTSxVQUFVLE9BQU9DLFFBQVEsTUFBTU8sUUFBUWIsVUFBVSxDQUFDTSxNQUFNO1FBQzFEO0lBQ0Y7SUFFQSxPQUFPRDtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU1IsTUFBTVEsTUFBTTtJQUNuQixJQUFJLENBQUNBLFFBQVE7UUFDWCxNQUFNLElBQUlOLFVBQVU7SUFDdEI7SUFFQSwyQ0FBMkM7SUFDM0MsSUFBSSxPQUFPTSxXQUFXLFVBQVU7UUFDOUJBLFNBQVNTLGVBQWVUO0lBQzFCO0lBRUEsSUFBSSxPQUFPQSxXQUFXLFVBQVU7UUFDOUIsTUFBTSxJQUFJTixVQUFVO0lBQ3RCO0lBRUEsSUFBSWdCLFFBQVFWLE9BQU9XLE9BQU8sQ0FBQztJQUMzQixJQUFJYixPQUFPWSxVQUFVLENBQUMsSUFDbEJWLE9BQU9ZLE1BQU0sQ0FBQyxHQUFHRixTQUNqQlY7SUFFSixJQUFJYTtJQUNKLElBQUlDO0lBQ0osSUFBSXJCLE1BQU1zQixVQUFVakI7SUFDcEIsSUFBSUksU0FBUyxDQUFDO0lBQ2QsSUFBSWM7SUFFSmxDLFlBQVltQyxTQUFTLEdBQUdQO0lBRXhCLE1BQU9JLFFBQVFoQyxZQUFZb0MsSUFBSSxDQUFDbEIsUUFBUztRQUN2QyxJQUFJYyxNQUFNSixLQUFLLEtBQUtBLE9BQU87WUFDekIsTUFBTSxJQUFJaEIsVUFBVTtRQUN0QjtRQUVBZ0IsU0FBU0ksS0FBSyxDQUFDLEVBQUUsQ0FBQ1AsTUFBTTtRQUN4Qk0sTUFBTUMsS0FBSyxDQUFDLEVBQUUsQ0FBQ0ssV0FBVztRQUMxQkgsUUFBUUYsS0FBSyxDQUFDLEVBQUU7UUFFaEIsSUFBSUUsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLO1lBQ3BCLDRCQUE0QjtZQUM1QkEsUUFBUUEsTUFDTEosTUFBTSxDQUFDLEdBQUdJLE1BQU1ULE1BQU0sR0FBRyxHQUN6QmEsT0FBTyxDQUFDbkMsWUFBWTtRQUN6QjtRQUVBaUIsTUFBTSxDQUFDVyxJQUFJLEdBQUdHO0lBQ2hCO0lBRUEsSUFBSU4sVUFBVSxDQUFDLEtBQUtBLFVBQVVWLE9BQU9PLE1BQU0sRUFBRTtRQUMzQyxNQUFNLElBQUliLFVBQVU7SUFDdEI7SUFFQUQsSUFBSUUsVUFBVSxHQUFHTztJQUVqQixPQUFPVDtBQUNUO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU2dCLGVBQWVoQixHQUFHO0lBQ3pCLElBQUksT0FBT0EsSUFBSTRCLFNBQVMsS0FBSyxZQUFZO1FBQ3ZDLFdBQVc7UUFDWCxPQUFPNUIsSUFBSTRCLFNBQVMsQ0FBQztJQUN2QjtJQUVBLElBQUksT0FBTzVCLElBQUk2QixPQUFPLEtBQUssVUFBVTtRQUNuQyxXQUFXO1FBQ1gsT0FBTzdCLElBQUk2QixPQUFPLElBQUk3QixJQUFJNkIsT0FBTyxDQUFDLGVBQWU7SUFDbkQ7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNkLFFBQVFlLEdBQUc7SUFDbEIsSUFBSUMsTUFBTUMsT0FBT0Y7SUFFakIsMEJBQTBCO0lBQzFCLElBQUl2QyxZQUFZZSxJQUFJLENBQUN5QixNQUFNO1FBQ3pCLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJQSxJQUFJakIsTUFBTSxHQUFHLEtBQUssQ0FBQ3hCLFdBQVdnQixJQUFJLENBQUN5QixNQUFNO1FBQzNDLE1BQU0sSUFBSTlCLFVBQVU7SUFDdEI7SUFFQSxPQUFPLE1BQU04QixJQUFJSixPQUFPLENBQUNsQyxhQUFhLFVBQVU7QUFDbEQ7QUFFQTs7Ozs7O0NBTUMsR0FFRCxTQUFTNkIsVUFBVWYsTUFBTTtJQUN2QixJQUFJYyxRQUFRekIsV0FBVzZCLElBQUksQ0FBQ2xCLE9BQU9tQixXQUFXO0lBRTlDLElBQUksQ0FBQ0wsT0FBTztRQUNWLE1BQU0sSUFBSXBCLFVBQVU7SUFDdEI7SUFFQSxJQUFJSSxPQUFPZ0IsS0FBSyxDQUFDLEVBQUU7SUFDbkIsSUFBSWxCLFVBQVVrQixLQUFLLENBQUMsRUFBRTtJQUN0QixJQUFJakI7SUFFSixzQkFBc0I7SUFDdEIsSUFBSWEsUUFBUWQsUUFBUThCLFdBQVcsQ0FBQztJQUNoQyxJQUFJaEIsVUFBVSxDQUFDLEdBQUc7UUFDaEJiLFNBQVNELFFBQVFnQixNQUFNLENBQUNGLFFBQVE7UUFDaENkLFVBQVVBLFFBQVFnQixNQUFNLENBQUMsR0FBR0Y7SUFDOUI7SUFFQSxJQUFJakIsTUFBTTtRQUNSSyxNQUFNQTtRQUNORixTQUFTQTtRQUNUQyxRQUFRQTtJQUNWO0lBRUEsT0FBT0o7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2UtY29tLy4vbm9kZV9tb2R1bGVzL21lZGlhLXR5cGVyL2luZGV4LmpzPzdlZTciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBtZWRpYS10eXBlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoICooIFwiO1wiIHBhcmFtZXRlciApIGluIFJGQyAyNjE2IHNlYyAzLjdcbiAqXG4gKiBwYXJhbWV0ZXIgICAgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiB8IHF1b3RlZC1zdHJpbmcgKVxuICogdG9rZW4gICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiBzZXBhcmF0b3JzICAgID0gXCIoXCIgfCBcIilcIiB8IFwiPFwiIHwgXCI+XCIgfCBcIkBcIlxuICogICAgICAgICAgICAgICB8IFwiLFwiIHwgXCI7XCIgfCBcIjpcIiB8IFwiXFxcIiB8IDxcIj5cbiAqICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgIHwgXCJ7XCIgfCBcIn1cIiB8IFNQIHwgSFRcbiAqIHF1b3RlZC1zdHJpbmcgPSAoIDxcIj4gKihxZHRleHQgfCBxdW90ZWQtcGFpciApIDxcIj4gKVxuICogcWR0ZXh0ICAgICAgICA9IDxhbnkgVEVYVCBleGNlcHQgPFwiPj5cbiAqIHF1b3RlZC1wYWlyICAgPSBcIlxcXCIgQ0hBUlxuICogQ0hBUiAgICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gKiBURVhUICAgICAgICAgID0gPGFueSBPQ1RFVCBleGNlcHQgQ1RMcywgYnV0IGluY2x1ZGluZyBMV1M+XG4gKiBMV1MgICAgICAgICAgID0gW0NSTEZdIDEqKCBTUCB8IEhUIClcbiAqIENSTEYgICAgICAgICAgPSBDUiBMRlxuICogQ1IgICAgICAgICAgICA9IDxVUy1BU0NJSSBDUiwgY2FycmlhZ2UgcmV0dXJuICgxMyk+XG4gKiBMRiAgICAgICAgICAgID0gPFVTLUFTQ0lJIExGLCBsaW5lZmVlZCAoMTApPlxuICogU1AgICAgICAgICAgICA9IDxVUy1BU0NJSSBTUCwgc3BhY2UgKDMyKT5cbiAqIFNIVCAgICAgICAgICAgPSA8VVMtQVNDSUkgSFQsIGhvcml6b250YWwtdGFiICg5KT5cbiAqIENUTCAgICAgICAgICAgPSA8YW55IFVTLUFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyIChvY3RldHMgMCAtIDMxKSBhbmQgREVMICgxMjcpPlxuICogT0NURVQgICAgICAgICA9IDxhbnkgOC1iaXQgc2VxdWVuY2Ugb2YgZGF0YT5cbiAqL1xudmFyIHBhcmFtUmVnRXhwID0gLzsgKihbISMkJSYnXFwqXFwrXFwtXFwuMC05QS1aXFxeX2BhLXpcXHx+XSspICo9ICooXCIoPzpbICFcXHUwMDIzLVxcdTAwNWJcXHUwMDVkLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdfFxcXFxbXFx1MDAyMC1cXHUwMDdlXSkqXCJ8WyEjJCUmJ1xcKlxcK1xcLVxcLjAtOUEtWlxcXl9gYS16XFx8fl0rKSAqL2c7XG52YXIgdGV4dFJlZ0V4cCA9IC9eW1xcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC9cbnZhciB0b2tlblJlZ0V4cCA9IC9eWyEjJCUmJ1xcKlxcK1xcLVxcLjAtOUEtWlxcXl9gYS16XFx8fl0rJC9cblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggcXVvdGVkLXBhaXIgaW4gUkZDIDI2MTZcbiAqXG4gKiBxdW90ZWQtcGFpciA9IFwiXFxcIiBDSEFSXG4gKiBDSEFSICAgICAgICA9IDxhbnkgVVMtQVNDSUkgY2hhcmFjdGVyIChvY3RldHMgMCAtIDEyNyk+XG4gKi9cbnZhciBxZXNjUmVnRXhwID0gL1xcXFwoW1xcdTAwMDAtXFx1MDA3Zl0pL2c7XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGNoYXJzIHRoYXQgbXVzdCBiZSBxdW90ZWQtcGFpciBpbiBSRkMgMjYxNlxuICovXG52YXIgcXVvdGVSZWdFeHAgPSAvKFtcXFxcXCJdKS9nO1xuXG4vKipcbiAqIFJlZ0V4cCB0byBtYXRjaCB0eXBlIGluIFJGQyA2ODM4XG4gKlxuICogdHlwZS1uYW1lID0gcmVzdHJpY3RlZC1uYW1lXG4gKiBzdWJ0eXBlLW5hbWUgPSByZXN0cmljdGVkLW5hbWVcbiAqIHJlc3RyaWN0ZWQtbmFtZSA9IHJlc3RyaWN0ZWQtbmFtZS1maXJzdCAqMTI2cmVzdHJpY3RlZC1uYW1lLWNoYXJzXG4gKiByZXN0cmljdGVkLW5hbWUtZmlyc3QgID0gQUxQSEEgLyBESUdJVFxuICogcmVzdHJpY3RlZC1uYW1lLWNoYXJzICA9IEFMUEhBIC8gRElHSVQgLyBcIiFcIiAvIFwiI1wiIC9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBcIiRcIiAvIFwiJlwiIC8gXCItXCIgLyBcIl5cIiAvIFwiX1wiXG4gKiByZXN0cmljdGVkLW5hbWUtY2hhcnMgPS8gXCIuXCIgOyBDaGFyYWN0ZXJzIGJlZm9yZSBmaXJzdCBkb3QgYWx3YXlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgc3BlY2lmeSBhIGZhY2V0IG5hbWVcbiAqIHJlc3RyaWN0ZWQtbmFtZS1jaGFycyA9LyBcIitcIiA7IENoYXJhY3RlcnMgYWZ0ZXIgbGFzdCBwbHVzIGFsd2F5c1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IHNwZWNpZnkgYSBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXhcbiAqIEFMUEhBID0gICV4NDEtNUEgLyAleDYxLTdBICAgOyBBLVogLyBhLXpcbiAqIERJR0lUID0gICV4MzAtMzkgICAgICAgICAgICAgOyAwLTlcbiAqL1xudmFyIHN1YnR5cGVOYW1lUmVnRXhwID0gL15bQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8uLV17MCwxMjZ9JC9cbnZhciB0eXBlTmFtZVJlZ0V4cCA9IC9eW0EtWmEtejAtOV1bQS1aYS16MC05ISMkJl5fLV17MCwxMjZ9JC9cbnZhciB0eXBlUmVnRXhwID0gL14gKihbQS1aYS16MC05XVtBLVphLXowLTkhIyQmXl8tXXswLDEyNn0pXFwvKFtBLVphLXowLTldW0EtWmEtejAtOSEjJCZeXy4rLV17MCwxMjZ9KSAqJC87XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXRcbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuXG4vKipcbiAqIEZvcm1hdCBvYmplY3QgdG8gbWVkaWEgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdChvYmopIHtcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBvYmogaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgdmFyIHBhcmFtZXRlcnMgPSBvYmoucGFyYW1ldGVyc1xuICB2YXIgc3VidHlwZSA9IG9iai5zdWJ0eXBlXG4gIHZhciBzdWZmaXggPSBvYmouc3VmZml4XG4gIHZhciB0eXBlID0gb2JqLnR5cGVcblxuICBpZiAoIXR5cGUgfHwgIXR5cGVOYW1lUmVnRXhwLnRlc3QodHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHR5cGUnKVxuICB9XG5cbiAgaWYgKCFzdWJ0eXBlIHx8ICFzdWJ0eXBlTmFtZVJlZ0V4cC50ZXN0KHN1YnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzdWJ0eXBlJylcbiAgfVxuXG4gIC8vIGZvcm1hdCBhcyB0eXBlL3N1YnR5cGVcbiAgdmFyIHN0cmluZyA9IHR5cGUgKyAnLycgKyBzdWJ0eXBlXG5cbiAgLy8gYXBwZW5kICtzdWZmaXhcbiAgaWYgKHN1ZmZpeCkge1xuICAgIGlmICghdHlwZU5hbWVSZWdFeHAudGVzdChzdWZmaXgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHN1ZmZpeCcpXG4gICAgfVxuXG4gICAgc3RyaW5nICs9ICcrJyArIHN1ZmZpeFxuICB9XG5cbiAgLy8gYXBwZW5kIHBhcmFtZXRlcnNcbiAgaWYgKHBhcmFtZXRlcnMgJiYgdHlwZW9mIHBhcmFtZXRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHBhcmFtXG4gICAgdmFyIHBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpLnNvcnQoKVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmFtID0gcGFyYW1zW2ldXG5cbiAgICAgIGlmICghdG9rZW5SZWdFeHAudGVzdChwYXJhbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgbmFtZScpXG4gICAgICB9XG5cbiAgICAgIHN0cmluZyArPSAnOyAnICsgcGFyYW0gKyAnPScgKyBxc3RyaW5nKHBhcmFtZXRlcnNbcGFyYW1dKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBQYXJzZSBtZWRpYSB0eXBlIHRvIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHN0cmluZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHJpbmcpIHtcbiAgaWYgKCFzdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgLy8gc3VwcG9ydCByZXEvcmVzLWxpa2Ugb2JqZWN0cyBhcyBhcmd1bWVudFxuICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICBzdHJpbmcgPSBnZXRjb250ZW50dHlwZShzdHJpbmcpXG4gIH1cblxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgdmFyIGluZGV4ID0gc3RyaW5nLmluZGV4T2YoJzsnKVxuICB2YXIgdHlwZSA9IGluZGV4ICE9PSAtMVxuICAgID8gc3RyaW5nLnN1YnN0cigwLCBpbmRleClcbiAgICA6IHN0cmluZ1xuXG4gIHZhciBrZXlcbiAgdmFyIG1hdGNoXG4gIHZhciBvYmogPSBzcGxpdFR5cGUodHlwZSlcbiAgdmFyIHBhcmFtcyA9IHt9XG4gIHZhciB2YWx1ZVxuXG4gIHBhcmFtUmVnRXhwLmxhc3RJbmRleCA9IGluZGV4XG5cbiAgd2hpbGUgKG1hdGNoID0gcGFyYW1SZWdFeHAuZXhlYyhzdHJpbmcpKSB7XG4gICAgaWYgKG1hdGNoLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgZm9ybWF0JylcbiAgICB9XG5cbiAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGhcbiAgICBrZXkgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgdmFsdWUgPSBtYXRjaFsyXVxuXG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICAvLyByZW1vdmUgcXVvdGVzIGFuZCBlc2NhcGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMilcbiAgICAgICAgLnJlcGxhY2UocWVzY1JlZ0V4cCwgJyQxJylcbiAgICB9XG5cbiAgICBwYXJhbXNba2V5XSA9IHZhbHVlXG4gIH1cblxuICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4ICE9PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbWV0ZXIgZm9ybWF0JylcbiAgfVxuXG4gIG9iai5wYXJhbWV0ZXJzID0gcGFyYW1zXG5cbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEdldCBjb250ZW50LXR5cGUgZnJvbSByZXEvcmVzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRjb250ZW50dHlwZShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmouZ2V0SGVhZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gcmVzLWxpa2VcbiAgICByZXR1cm4gb2JqLmdldEhlYWRlcignY29udGVudC10eXBlJylcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLmhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gcmVxLWxpa2VcbiAgICByZXR1cm4gb2JqLmhlYWRlcnMgJiYgb2JqLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gIH1cbn1cblxuLyoqXG4gKiBRdW90ZSBhIHN0cmluZyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHJldHVybiB7c3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXN0cmluZyh2YWwpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyh2YWwpXG5cbiAgLy8gbm8gbmVlZCB0byBxdW90ZSB0b2tlbnNcbiAgaWYgKHRva2VuUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIGlmIChzdHIubGVuZ3RoID4gMCAmJiAhdGV4dFJlZ0V4cC50ZXN0KHN0cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtZXRlciB2YWx1ZScpXG4gIH1cblxuICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKHF1b3RlUmVnRXhwLCAnXFxcXCQxJykgKyAnXCInXG59XG5cbi8qKlxuICogU2ltcGx5IFwidHlwZS9zdWJ0eXBlK3NpZmZ4XCIgaW50byBwYXJ0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdFR5cGUoc3RyaW5nKSB7XG4gIHZhciBtYXRjaCA9IHR5cGVSZWdFeHAuZXhlYyhzdHJpbmcudG9Mb3dlckNhc2UoKSlcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBtZWRpYSB0eXBlJylcbiAgfVxuXG4gIHZhciB0eXBlID0gbWF0Y2hbMV1cbiAgdmFyIHN1YnR5cGUgPSBtYXRjaFsyXVxuICB2YXIgc3VmZml4XG5cbiAgLy8gc3VmZml4IGFmdGVyIGxhc3QgK1xuICB2YXIgaW5kZXggPSBzdWJ0eXBlLmxhc3RJbmRleE9mKCcrJylcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHN1ZmZpeCA9IHN1YnR5cGUuc3Vic3RyKGluZGV4ICsgMSlcbiAgICBzdWJ0eXBlID0gc3VidHlwZS5zdWJzdHIoMCwgaW5kZXgpXG4gIH1cblxuICB2YXIgb2JqID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc3VidHlwZTogc3VidHlwZSxcbiAgICBzdWZmaXg6IHN1ZmZpeFxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuIl0sIm5hbWVzIjpbInBhcmFtUmVnRXhwIiwidGV4dFJlZ0V4cCIsInRva2VuUmVnRXhwIiwicWVzY1JlZ0V4cCIsInF1b3RlUmVnRXhwIiwic3VidHlwZU5hbWVSZWdFeHAiLCJ0eXBlTmFtZVJlZ0V4cCIsInR5cGVSZWdFeHAiLCJleHBvcnRzIiwiZm9ybWF0IiwicGFyc2UiLCJvYmoiLCJUeXBlRXJyb3IiLCJwYXJhbWV0ZXJzIiwic3VidHlwZSIsInN1ZmZpeCIsInR5cGUiLCJ0ZXN0Iiwic3RyaW5nIiwicGFyYW0iLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsImkiLCJsZW5ndGgiLCJxc3RyaW5nIiwiZ2V0Y29udGVudHR5cGUiLCJpbmRleCIsImluZGV4T2YiLCJzdWJzdHIiLCJrZXkiLCJtYXRjaCIsInNwbGl0VHlwZSIsInZhbHVlIiwibGFzdEluZGV4IiwiZXhlYyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsImdldEhlYWRlciIsImhlYWRlcnMiLCJ2YWwiLCJzdHIiLCJTdHJpbmciLCJsYXN0SW5kZXhPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/media-typer/index.js\n");

/***/ })

};
;